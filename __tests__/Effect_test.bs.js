// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Random = require("bs-platform/lib/js/random.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

function make(f) {
  return f;
}

function run(receiver, task) {
  return Curry._1(task, receiver);
}

function map(f, task, resolve) {
  return Curry._1(task, (function (a) {
                return Curry._1(resolve, Curry._1(f, a));
              }));
}

function $$const(value) {
  return (function (f) {
      return Curry._1(f, value);
    });
}

function randomInt(l, h, f) {
  return Curry._1(f, Random.$$int(h) + l | 0);
}

var Task = /* module */[
  /* make */make,
  /* run */run,
  /* map */map,
  /* const */$$const,
  /* randomInt */randomInt
];

Jest.describe("Task", (function (param) {
        Jest.testAsync("make", undefined, (function (finish) {
                var expected = "my-value";
                return Curry._1(finish, Jest.Expect[/* toBe */2](expected, Jest.Expect[/* expect */0](expected)));
              }));
        Jest.testAsync("map", undefined, (function (finish) {
                var f = function (x) {
                  return x + 5 | 0;
                };
                var value = Curry._1(f, 3);
                return Curry._1(finish, Jest.Expect[/* toBe */2](8, Jest.Expect[/* expect */0](value)));
              }));
        return Jest.testAsync("const", undefined, (function (finish) {
                      var expected = "my-value";
                      return Curry._1(finish, Jest.Expect[/* toBe */2](expected, Jest.Expect[/* expect */0](expected)));
                    }));
      }));

function $$const$1(value) {
  return /* :: */[
          /* Update */Block.__(0, [(function (param) {
                  return value;
                })]),
          /* [] */0
        ];
}

function update(updater) {
  return /* :: */[
          /* Update */Block.__(0, [updater]),
          /* [] */0
        ];
}

function do_(action, mapper) {
  return /* :: */[
          /* Task */Block.__(1, [(function (model) {
                  var partial_arg = Curry._1(action, model);
                  return (function (param) {
                      return Curry._1(partial_arg, (function (a) {
                                    return Curry._1(param, Curry._1(mapper, a));
                                  }));
                    });
                })]),
          /* [] */0
        ];
}

function andThen(last, param) {
  if (param) {
    var match = param[0];
    if (match.tag) {
      return /* :: */[
              /* Task */Block.__(1, [match[0]]),
              andThen(last, param[1])
            ];
    } else {
      return /* :: */[
              /* Update */Block.__(0, [match[0]]),
              andThen(last, param[1])
            ];
    }
  } else {
    return last;
  }
}

function map$1(get, set, param) {
  if (param) {
    var match = param[0];
    if (match.tag) {
      var f = match[0];
      return /* :: */[
              /* Task */Block.__(1, [(function (model) {
                      var partial_arg = Curry._1(f, Curry._1(get, model));
                      return (function (param) {
                          var f = function (f$1, model) {
                            return Curry._2(set, model, Curry._1(f$1, Curry._1(get, model)));
                          };
                          return Curry._1(partial_arg, (function (a) {
                                        return Curry._1(param, Curry._1(f, a));
                                      }));
                        });
                    })]),
              map$1(get, set, param[1])
            ];
    } else {
      var f$1 = match[0];
      return /* :: */[
              /* Update */Block.__(0, [(function (model) {
                      return Curry._2(set, model, Curry._1(f$1, Curry._1(get, model)));
                    })]),
              map$1(get, set, param[1])
            ];
    }
  } else {
    return /* [] */0;
  }
}

function step(model, param) {
  if (param) {
    var match = param[0];
    if (match.tag) {
      var rest = param[1];
      var partial_arg = Curry._1(match[0], model);
      var next = function (param) {
        var f = function (f$prime) {
          return /* :: */[
                  /* Update */Block.__(0, [f$prime]),
                  rest
                ];
        };
        return Curry._1(partial_arg, (function (a) {
                      return Curry._1(param, Curry._1(f, a));
                    }));
      };
      return /* tuple */[
              undefined,
              Caml_option.some(next)
            ];
    } else {
      var rest$1 = param[1];
      var f = match[0];
      if (rest$1) {
        return /* tuple */[
                Caml_option.some(Curry._1(f, model)),
                Caml_option.some((function (f) {
                        return Curry._1(f, rest$1);
                      }))
              ];
      } else {
        return /* tuple */[
                Caml_option.some(Curry._1(f, model)),
                undefined
              ];
      }
    }
  } else {
    return /* tuple */[
            undefined,
            undefined
          ];
  }
}

var Effect = /* module */[
  /* none : [] */0,
  /* const */$$const$1,
  /* update */update,
  /* do_ */do_,
  /* andThen */andThen,
  /* map */map$1,
  /* step */step
];

Jest.describe("Effect", (function (param) {
        var run = function (effect, model, callback) {
          var aux = function (model, result, effect) {
            var match = step(model, effect);
            var next = match[1];
            var maybeValue = match[0];
            var match$1;
            if (maybeValue !== undefined) {
              var value = Caml_option.valFromOption(maybeValue);
              match$1 = /* tuple */[
                value,
                /* :: */[
                  value,
                  result
                ]
              ];
            } else {
              match$1 = /* tuple */[
                model,
                result
              ];
            }
            var result$1 = match$1[1];
            var model$1 = match$1[0];
            if (next !== undefined) {
              return Curry._1(Caml_option.valFromOption(next), (function (param) {
                            return aux(model$1, result$1, param);
                          }));
            } else {
              return Curry._1(callback, List.rev(result$1));
            }
          };
          return aux(model, /* [] */0, effect);
        };
        Jest.test("const", (function (param) {
                var effect_000 = /* Update */Block.__(0, [(function (param) {
                        return 42;
                      })]);
                var effect = /* :: */[
                  effect_000,
                  /* [] */0
                ];
                var match = step(0, effect);
                return Jest.Expect[/* toEqual */12](/* tuple */[
                            42,
                            undefined
                          ], Jest.Expect[/* expect */0](/* tuple */[
                                match[0],
                                match[1]
                              ]));
              }));
        Jest.test("update", (function (param) {
                var effect_000 = /* Update */Block.__(0, [(function (model) {
                        return model + 1 | 0;
                      })]);
                var effect = /* :: */[
                  effect_000,
                  /* [] */0
                ];
                var match = step(2, effect);
                return Jest.Expect[/* toEqual */12](/* tuple */[
                            3,
                            undefined
                          ], Jest.Expect[/* expect */0](/* tuple */[
                                match[0],
                                match[1]
                              ]));
              }));
        Jest.testAsync("do_", undefined, (function (finish) {
                var effect = do_((function (model) {
                        var value = model + 1 | 0;
                        return (function (f) {
                            return Curry._1(f, value);
                          });
                      }), (function (model, value) {
                        return model + value | 0;
                      }));
                return run(effect, 2, (function (result) {
                              return Curry._1(finish, Jest.Expect[/* toEqual */12](/* :: */[
                                              5,
                                              /* [] */0
                                            ], Jest.Expect[/* expect */0](result)));
                            }));
              }));
        Jest.testAsync("andThen", undefined, (function (finish) {
                var effect = andThen(/* :: */[
                      /* Update */Block.__(0, [(function (model) {
                              return /* record */[
                                      /* number */model[/* number */0],
                                      /* text */String(model[/* number */0])
                                    ];
                            })]),
                      /* [] */0
                    ], do_((function (model) {
                            var value = model[/* number */0] + 1 | 0;
                            return (function (f) {
                                return Curry._1(f, value);
                              });
                          }), (function (result, model) {
                            return /* record */[
                                    /* number */result,
                                    /* text */model[/* text */1]
                                  ];
                          })));
                return run(effect, /* record */[
                            /* number */1,
                            /* text */"foo"
                          ], (function (result) {
                              return Curry._1(finish, Jest.Expect[/* toEqual */12](/* :: */[
                                              /* record */[
                                                /* number */2,
                                                /* text */"foo"
                                              ],
                                              /* :: */[
                                                /* record */[
                                                  /* number */2,
                                                  /* text */"2"
                                                ],
                                                /* [] */0
                                              ]
                                            ], Jest.Expect[/* expect */0](result)));
                            }));
              }));
        return Jest.test("map", (function (param) {
                      var effect = map$1((function (model) {
                              return model[/* number */0];
                            }), (function (model, number) {
                              return /* record */[
                                      /* number */number,
                                      /* text */model[/* text */1]
                                    ];
                            }), /* :: */[
                            /* Update */Block.__(0, [(function (model) {
                                    return model + 1 | 0;
                                  })]),
                            /* [] */0
                          ]);
                      var match = step(/* record */[
                            /* number */4,
                            /* text */"bar"
                          ], effect);
                      return Jest.Expect[/* toEqual */12](/* tuple */[
                                  /* record */[
                                    /* number */5,
                                    /* text */"bar"
                                  ],
                                  undefined
                                ], Jest.Expect[/* expect */0](/* tuple */[
                                      match[0],
                                      match[1]
                                    ]));
                    }));
      }));

exports.Task = Task;
exports.Effect = Effect;
/*  Not a pure module */
