// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

var Dom = /* module */[];

function empty(prim) {
  return { };
}

function set(prim, prim$1, prim$2) {
  prim[prim$1] = prim$2;
  return /* () */0;
}

var Dict = /* module */[
  /* empty */empty,
  /* get */Js_dict.get,
  /* set */set,
  /* values */Js_dict.values
];

function make(namespace, key, value) {
  return /* record */[
          /* namespace */namespace,
          /* key */key,
          /* value */value
        ];
}

var Attribute = /* module */[/* make */make];

function dekey(node) {
  switch (node.tag | 0) {
    case 0 : 
    case 1 : 
        return node;
    case 2 : 
        var match = node[0];
        return /* Element */Block.__(1, [/* record */[
                    /* namespace */match[/* namespace */0],
                    /* tag */match[/* tag */1],
                    /* properties */match[/* properties */2],
                    /* children */List.map((function (param) {
                            return dekey(param[1]);
                          }), match[/* children */3])
                  ]]);
    
  }
}

function text(s) {
  return /* Text */Block.__(0, [s]);
}

function element(namespace, tag, properties, children) {
  return /* Element */Block.__(1, [/* record */[
              /* namespace */namespace,
              /* tag */tag,
              /* properties */properties,
              /* children */children
            ]]);
}

function element$1(namespace, tag, properties, children) {
  return /* KeyedElement */Block.__(2, [/* record */[
              /* namespace */namespace,
              /* tag */tag,
              /* properties */properties,
              /* children */children
            ]]);
}

var Keyed = /* module */[/* element */element$1];

var $$Node = /* module */[
  /* dekey */dekey,
  /* text */text,
  /* element */element,
  /* Keyed */Keyed
];

function diff(rootDomNode, oldVTree, newVTree) {
  var diffNode = function (domNode, patches, oVNode, _nVNode) {
    while(true) {
      var nVNode = _nVNode;
      var exit = 0;
      switch (oVNode.tag | 0) {
        case 0 : 
            switch (nVNode.tag | 0) {
              case 0 : 
                  var nText = nVNode[0];
                  if (oVNode[0] === nText) {
                    return patches;
                  } else {
                    return /* :: */[
                            /* SetText */Block.__(3, [
                                domNode,
                                nText
                              ]),
                            patches
                          ];
                  }
              case 1 : 
              case 2 : 
                  exit = 1;
                  break;
              
            }
            break;
        case 1 : 
            var o = oVNode[0];
            switch (nVNode.tag | 0) {
              case 0 : 
                  exit = 1;
                  break;
              case 1 : 
                  var n = nVNode[0];
                  if (o[/* tag */1] === n[/* tag */1] && Caml_obj.caml_equal(o[/* namespace */0], n[/* namespace */0])) {
                    var patches$1 = diffProperties(domNode, patches, o[/* properties */2], n[/* properties */2]);
                    var parentDomNode = domNode;
                    var _patches = patches$1;
                    var _oldVNodes = o[/* children */3];
                    var _newVNodes = n[/* children */3];
                    var _index = 0;
                    while(true) {
                      var index = _index;
                      var newVNodes = _newVNodes;
                      var oldVNodes = _oldVNodes;
                      var patches$2 = _patches;
                      if (oldVNodes) {
                        if (newVNodes) {
                          var childDomNodes = parentDomNode.childNodes;
                          var match = childDomNodes[index];
                          var patches$3 = match !== undefined ? diffNode(match, patches$2, oldVNodes[0], newVNodes[0]) : Pervasives.failwith("well this shouldn't happen");
                          _index = index + 1 | 0;
                          _newVNodes = newVNodes[1];
                          _oldVNodes = oldVNodes[1];
                          _patches = patches$3;
                          continue ;
                        } else {
                          return /* :: */[
                                  /* PopNodes */Block.__(2, [
                                      parentDomNode,
                                      List.length(oldVNodes)
                                    ]),
                                  patches$2
                                ];
                        }
                      } else if (newVNodes) {
                        return /* :: */[
                                /* PushNodes */Block.__(1, [
                                    parentDomNode,
                                    newVNodes
                                  ]),
                                patches$2
                              ];
                      } else {
                        return patches$2;
                      }
                    };
                  } else {
                    return /* :: */[
                            /* Rerender */Block.__(0, [
                                domNode,
                                nVNode
                              ]),
                            patches
                          ];
                  }
              case 2 : 
                  _nVNode = dekey(nVNode);
                  continue ;
              
            }
            break;
        case 2 : 
            var o$1 = oVNode[0];
            switch (nVNode.tag | 0) {
              case 0 : 
              case 1 : 
                  exit = 1;
                  break;
              case 2 : 
                  var n$1 = nVNode[0];
                  if (o$1[/* tag */1] === n$1[/* tag */1] && Caml_obj.caml_equal(o$1[/* namespace */0], n$1[/* namespace */0])) {
                    var patches$4 = diffProperties(domNode, patches, o$1[/* properties */2], n$1[/* properties */2]);
                    var parentDomNode$1 = domNode;
                    var patches$5 = patches$4;
                    var oldVNodes$1 = o$1[/* children */3];
                    var newVNodes$1 = n$1[/* children */3];
                    var key_SUFFIX = "_rlm";
                    var changes = { };
                    var insert = (function(changes){
                    return function insert(_key, node, index) {
                      while(true) {
                        var key = _key;
                        var match = Js_dict.get(changes, key);
                        if (match !== undefined) {
                          var match$1 = match;
                          if (typeof match$1 === "number") {
                            _key = key + key_SUFFIX;
                            continue ;
                          } else if (match$1[0] !== 958206052) {
                            _key = key + key_SUFFIX;
                            continue ;
                          } else {
                            return set(changes, key, /* `Move */[
                                        859442993,
                                        /* tuple */[
                                          match$1[1],
                                          index
                                        ]
                                      ]);
                          }
                        } else {
                          return set(changes, key, /* `Insert */[
                                      -764299431,
                                      /* tuple */[
                                        node,
                                        index
                                      ]
                                    ]);
                        }
                      };
                    }
                    }(changes));
                    var remove = (function(changes){
                    return function remove(_key, node, index) {
                      while(true) {
                        var key = _key;
                        var match = Js_dict.get(changes, key);
                        if (match !== undefined) {
                          var match$1 = match;
                          if (typeof match$1 === "number") {
                            _key = key + key_SUFFIX;
                            continue ;
                          } else if (match$1[0] !== -764299431) {
                            _key = key + key_SUFFIX;
                            continue ;
                          } else {
                            return set(changes, key, /* `Move */[
                                        859442993,
                                        /* tuple */[
                                          index,
                                          match$1[1][1]
                                        ]
                                      ]);
                          }
                        } else {
                          return set(changes, key, /* `Remove */[
                                      958206052,
                                      index
                                    ]);
                        }
                      };
                    }
                    }(changes));
                    var diffChildNode = (function(parentDomNode$1,patches$5){
                    return function diffChildNode(oVNode, nVNode, index) {
                      var childDomNodes = parentDomNode$1.childNodes;
                      var match = childDomNodes[index];
                      if (match !== undefined) {
                        return diffNode(match, patches$5, oVNode, nVNode);
                      } else {
                        return Pervasives.failwith("well this shouldn't happen");
                      }
                    }
                    }(parentDomNode$1,patches$5));
                    var helper = (function(parentDomNode$1){
                    return function helper(_patches, _oldVNodes, _newVNodes, _index) {
                      while(true) {
                        var index = _index;
                        var newVNodes = _newVNodes;
                        var oldVNodes = _oldVNodes;
                        var patches = _patches;
                        if (oldVNodes) {
                          if (newVNodes) {
                            var nRest = newVNodes[1];
                            var match = newVNodes[0];
                            var nVNode = match[1];
                            var nKey = match[0];
                            var oRest = oldVNodes[1];
                            var match$1 = oldVNodes[0];
                            var oVNode = match$1[1];
                            var oKey = match$1[0];
                            if (oKey === nKey) {
                              var patches$1 = diffChildNode(oVNode, nVNode, index);
                              _index = index + 1 | 0;
                              _newVNodes = nRest;
                              _oldVNodes = oRest;
                              _patches = patches$1;
                              continue ;
                            } else {
                              var exit = 0;
                              if (oRest && nRest) {
                                var nNextRest = nRest[1];
                                var nNextKey = nRest[0][0];
                                var oNextRest = oRest[1];
                                var oNextKey = oRest[0][0];
                                if (oKey === nNextKey && nKey === oNextKey) {
                                  insert(nKey, nVNode, index);
                                  remove(oKey, oVNode, index + 1 | 0);
                                  _index = index + 1 | 0;
                                  _newVNodes = nNextRest;
                                  _oldVNodes = oNextRest;
                                  continue ;
                                } else if (oKey === nNextKey) {
                                  insert(nKey, nVNode, index);
                                  _index = index + 2 | 0;
                                  _newVNodes = nNextRest;
                                  _oldVNodes = oRest;
                                  continue ;
                                } else {
                                  remove(oKey, oVNode, index);
                                  if (nKey === oNextKey) {
                                    _index = index + 1 | 0;
                                    _newVNodes = nRest;
                                    _oldVNodes = oNextRest;
                                    continue ;
                                  } else {
                                    insert(nKey, nVNode, index);
                                    _index = index + 1 | 0;
                                    _newVNodes = nRest;
                                    _oldVNodes = oRest;
                                    continue ;
                                  }
                                }
                              } else {
                                exit = 1;
                              }
                              if (exit === 1) {
                                _index = index + 1 | 0;
                                _newVNodes = nRest;
                                _oldVNodes = oRest;
                                continue ;
                              }
                              
                            }
                          } else {
                            return /* :: */[
                                    /* PopNodes */Block.__(2, [
                                        parentDomNode$1,
                                        List.length(oldVNodes)
                                      ]),
                                    patches
                                  ];
                          }
                        } else if (newVNodes) {
                          return /* :: */[
                                  /* PushNodes */Block.__(1, [
                                      parentDomNode$1,
                                      List.map((function (prim) {
                                              return prim[1];
                                            }), newVNodes)
                                    ]),
                                  patches
                                ];
                        } else {
                          return patches;
                        }
                      };
                    }
                    }(parentDomNode$1));
                    var patches$6 = helper(patches$5, oldVNodes$1, newVNodes$1, 0);
                    return /* :: */[
                            /* Reorder */Block.__(6, [
                                parentDomNode$1,
                                Js_dict.values(changes)
                              ]),
                            patches$6
                          ];
                  } else {
                    return /* :: */[
                            /* Rerender */Block.__(0, [
                                domNode,
                                nVNode
                              ]),
                            patches
                          ];
                  }
              
            }
            break;
        
      }
      if (exit === 1) {
        return /* :: */[
                /* Rerender */Block.__(0, [
                    domNode,
                    nVNode
                  ]),
                patches
              ];
      }
      
    };
  };
  var diffProperties = function (domNode, patches, oldProperties, newProperties) {
    var isMatch = function (x, y) {
      if (x.tag) {
        if (y.tag) {
          return x[0] === y[0];
        } else {
          return false;
        }
      } else {
        var o = x[0];
        if (y.tag) {
          return false;
        } else {
          var n = y[0];
          if (Caml_obj.caml_equal(o[/* namespace */0], n[/* namespace */0])) {
            return o[/* key */1] === n[/* key */1];
          } else {
            return false;
          }
        }
      }
    };
    var onResult = function (patches, x, y) {
      if (x !== undefined) {
        var oldProperty = x;
        if (y !== undefined) {
          var newProperty = y;
          if (oldProperty.tag) {
            if (newProperty.tag) {
              return /* :: */[
                      /* RemoveProperty */Block.__(5, [
                          domNode,
                          oldProperty
                        ]),
                      /* :: */[
                        /* SetProperty */Block.__(4, [
                            domNode,
                            newProperty
                          ]),
                        patches
                      ]
                    ];
            } else {
              return patches;
            }
          } else if (newProperty.tag || oldProperty[0][/* value */2] === newProperty[0][/* value */2]) {
            return patches;
          } else {
            return /* :: */[
                    /* SetProperty */Block.__(4, [
                        domNode,
                        newProperty
                      ]),
                    patches
                  ];
          }
        } else {
          return /* :: */[
                  /* RemoveProperty */Block.__(5, [
                      domNode,
                      oldProperty
                    ]),
                  patches
                ];
        }
      } else if (y !== undefined) {
        return /* :: */[
                /* SetProperty */Block.__(4, [
                    domNode,
                    y
                  ]),
                patches
              ];
      } else {
        return patches;
      }
    };
    var isMatch$1 = isMatch;
    var onResult$1 = onResult;
    var acc = patches;
    var allXs = oldProperties;
    var allYs = newProperties;
    var processXs = function (_acc, _xs, _ys) {
      while(true) {
        var ys = _ys;
        var xs = _xs;
        var acc = _acc;
        if (xs) {
          var remainingXs = xs[1];
          var x = xs[0];
          if (ys) {
            var y = ys[0];
            if (Curry._2(isMatch$1, x, y)) {
              var acc$1 = Curry._3(onResult$1, acc, Caml_option.some(x), Caml_option.some(y));
              _ys = allYs;
              _xs = remainingXs;
              _acc = acc$1;
              continue ;
            } else {
              _ys = ys[1];
              continue ;
            }
          } else {
            var acc$2 = Curry._3(onResult$1, acc, Caml_option.some(x), undefined);
            _ys = allYs;
            _xs = remainingXs;
            _acc = acc$2;
            continue ;
          }
        } else {
          return acc;
        }
      };
    };
    var acc$1 = processXs(acc, allXs, allYs);
    var _acc = acc$1;
    var _xs = allXs;
    var _ys = allYs;
    while(true) {
      var ys = _ys;
      var xs = _xs;
      var acc$2 = _acc;
      if (ys) {
        if (xs) {
          if (Curry._2(isMatch$1, xs[0], ys[0])) {
            _ys = ys[1];
            continue ;
          } else {
            _xs = xs[1];
            continue ;
          }
        } else {
          var acc$3 = Curry._3(onResult$1, acc$2, undefined, Caml_option.some(ys[0]));
          _ys = ys[1];
          _xs = allXs;
          _acc = acc$3;
          continue ;
        }
      } else {
        return acc$2;
      }
    };
  };
  var match = rootDomNode.firstChild;
  if (match !== undefined) {
    return diffNode(match, /* [] */0, oldVTree, newVTree);
  } else {
    return Pervasives.failwith("no dom");
  }
}

function render(node) {
  switch (node.tag | 0) {
    case 0 : 
        return document.createTextNode(node[0]);
    case 1 : 
        var spec = node[0];
        var match = spec[/* namespace */0];
        var el = match !== undefined ? document.createElementNS(match, spec[/* tag */1]) : document.createElement(spec[/* tag */1]);
        List.iter((function (param) {
                if (param.tag) {
                  el.addEventListener(param[0], param[1]);
                  return /* () */0;
                } else {
                  var attr = param[0];
                  var match = attr[/* namespace */0];
                  if (match !== undefined) {
                    el.setAttribute(match, attr[/* key */1], attr[/* value */2]);
                    return /* () */0;
                  } else {
                    el.setAttribute(attr[/* key */1], attr[/* value */2]);
                    return /* () */0;
                  }
                }
              }), spec[/* properties */2]);
        List.iter((function (child) {
                el.appendChild(render(child));
                return /* () */0;
              }), spec[/* children */3]);
        return el;
    case 2 : 
        var spec$1 = node[0];
        var match$1 = spec$1[/* namespace */0];
        var el$1 = match$1 !== undefined ? document.createElementNS(match$1, spec$1[/* tag */1]) : document.createElement(spec$1[/* tag */1]);
        List.iter((function (param) {
                if (param.tag) {
                  el$1.addEventListener(param[0], param[1]);
                  return /* () */0;
                } else {
                  var attr = param[0];
                  var match = attr[/* namespace */0];
                  if (match !== undefined) {
                    el$1.setAttribute(match, attr[/* key */1], attr[/* value */2]);
                    return /* () */0;
                  } else {
                    el$1.setAttribute(attr[/* key */1], attr[/* value */2]);
                    return /* () */0;
                  }
                }
              }), spec$1[/* properties */2]);
        List.iter((function (param) {
                el$1.appendChild(render(param[1]));
                return /* () */0;
              }), spec$1[/* children */3]);
        return el$1;
    
  }
}

function patch(param) {
  return List.iter((function (param) {
                switch (param.tag | 0) {
                  case 0 : 
                      var domNode = param[0];
                      var match = domNode.parentNode;
                      if (match !== undefined) {
                        match.replaceChild(render(param[1]), domNode);
                        return /* () */0;
                      } else {
                        return /* () */0;
                      }
                  case 1 : 
                      var domNode$1 = param[0];
                      return List.iter((function (node) {
                                    domNode$1.appendChild(render(node));
                                    return /* () */0;
                                  }), param[1]);
                  case 2 : 
                      var domNode$2 = param[0];
                      for(var _for = 1 ,_for_finish = param[1]; _for <= _for_finish; ++_for){
                        var match$1 = domNode$2.lastChild;
                        if (match$1 !== undefined) {
                          domNode$2.removeChild(match$1);
                        }
                        
                      }
                      return /* () */0;
                  case 3 : 
                      var domNode$3 = param[0];
                      domNode$3.replaceData(0, domNode$3.length, param[1]);
                      return /* () */0;
                  case 4 : 
                      var property = param[1];
                      var domNode$4 = param[0];
                      if (property.tag) {
                        domNode$4.addEventListener(property[0], property[1]);
                        return /* () */0;
                      } else {
                        var attr = property[0];
                        domNode$4.setAttribute(attr[/* key */1], attr[/* value */2]);
                        return /* () */0;
                      }
                  case 5 : 
                      var property$1 = param[1];
                      var domNode$5 = param[0];
                      if (property$1.tag) {
                        domNode$5.removeEventListener(property$1[0], property$1[1]);
                        return /* () */0;
                      } else {
                        domNode$5.removeAttribute(property$1[0][/* key */1]);
                        return /* () */0;
                      }
                  case 6 : 
                      var domNode$6 = param[0];
                      return $$Array.iter((function (param) {
                                    var variant = param[0];
                                    if (variant !== 859442993) {
                                      if (variant >= 958206052) {
                                        var match = domNode$6.childNodes[param[1]];
                                        if (match !== undefined) {
                                          domNode$6.removeChild(match);
                                          return /* () */0;
                                        } else {
                                          return /* () */0;
                                        }
                                      } else {
                                        var match$1 = param[1];
                                        var match$2 = domNode$6.childNodes[match$1[1]];
                                        if (match$2 !== undefined) {
                                          domNode$6.insertBefore(render(match$1[0]), match$2);
                                          return /* () */0;
                                        } else {
                                          return /* () */0;
                                        }
                                      }
                                    } else {
                                      var match$3 = param[1];
                                      var match$4 = domNode$6.childNodes[match$3[0]];
                                      if (match$4 !== undefined) {
                                        domNode$6.removeChild(match$4);
                                        var match$5 = domNode$6.childNodes[match$3[1]];
                                        if (match$5 !== undefined) {
                                          domNode$6.insertBefore(match$4, match$5);
                                          return /* () */0;
                                        } else {
                                          return /* () */0;
                                        }
                                      } else {
                                        return /* () */0;
                                      }
                                    }
                                  }), param[1]);
                  
                }
              }), param);
}

function pp_node(param) {
  switch (param.tag | 0) {
    case 0 : 
        return "Text " + (String(param[0]) + " ");
    case 1 : 
        return "Element " + (String(param[0][/* tag */1]) + " ");
    case 2 : 
        return "KeyedElement " + (String(param[0][/* tag */1]) + " ");
    
  }
}

function pp_change(param) {
  var variant = param[0];
  if (variant !== 859442993) {
    if (variant >= 958206052) {
      return "Remove " + (String(param[1]) + "");
    } else {
      var match = param[1];
      return "Insert " + (String(match[1]) + (" " + (String(match[0]) + "")));
    }
  } else {
    var match$1 = param[1];
    return "Move " + (String(match$1[0]) + (" " + (String(match$1[1]) + "")));
  }
}

function pp_patch(param) {
  switch (param.tag | 0) {
    case 0 : 
        var text = pp_node(param[1]);
        return "Rerender " + (String(text) + "");
    case 1 : 
        var length = List.length(param[1]);
        return "PushNodes " + (String(length) + "");
    case 2 : 
        return "PopNodes " + (String(param[1]) + " ");
    case 3 : 
        return "SetText " + (String(param[1]) + "");
    case 4 : 
        return "SetProperty " + (String(param[1]) + "");
    case 5 : 
        return "RemoveProperty " + (String(param[1]) + "");
    case 6 : 
        var changes = $$Array.map(pp_change, param[1]);
        return "Reorder " + (String(changes) + "");
    
  }
}

exports.Dom = Dom;
exports.Dict = Dict;
exports.Attribute = Attribute;
exports.$$Node = $$Node;
exports.diff = diff;
exports.render = render;
exports.patch = patch;
exports.pp_node = pp_node;
exports.pp_change = pp_change;
exports.pp_patch = pp_patch;
/* No side effect */
